This patch is the diff between v9.0.3 and VEX head as of 2015-11-04.
This adds support for AVX instructions.

VEX current:

commit 3934376331fd9a69506398d98e3ff15cc05c6ea9 (HEAD, origin/VEX, VEX)
Author: Bill Williams <bill@cs.wisc.edu>
Date:   Fri Oct 23 14:58:54 2015 -0500

    ICC sample works

Version v9.0.3:

commit 5065988cd9cac1029befe74c37f1adac0f974182 (tag: v9.0.3)
Author: Josh Stone <jistone@redhat.com>
Date:   Tue Aug 25 16:26:33 2015 -0700

    dynC: use dyninst_library() to get the proper soname



diff --git a/CMakeLists.txt b/CMakeLists.txt
index 0ccd4b4..2b5a7c2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -62,22 +62,24 @@ add_subdirectory (common)
 if(NOT ${PLATFORM} MATCHES nt)
   add_subdirectory (elf)
   add_subdirectory (dwarf)
-if(SYMREADER MATCHES symLite)
   add_subdirectory (symlite)
-endif()
 # DynC is not compatible with Windows when
 # we use bison on linux to generate source
 # TODO: generate with bison configured for
 # MSVC?
+if(${SYMREADER} MATCHES symtabAPI)
   add_subdirectory (dynC_API)
 endif()
+endif()
 add_subdirectory (instructionAPI)
 add_subdirectory (symtabAPI)
 add_subdirectory (parseAPI)
-add_subdirectory (patchAPI)
 add_subdirectory (proccontrol)
 add_subdirectory (stackwalk)
-add_subdirectory (dyninstAPI)
+add_subdirectory (patchAPI)
+if(${SYMREADER} MATCHES symtabAPI)
+  add_subdirectory (dyninstAPI)
+endif()
 
 #Build the RT library as a seperate project so we can change compilers
 message(STATUS "Configuring DyninstAPI_RT")
@@ -119,17 +121,17 @@ install(SCRIPT "${RT_BINARY_DIR}/cmake_install.cmake")
 set (VERSION_STRING "${DYNINST_MAJOR_VERSION}.${DYNINST_MINOR_VERSION}.${DYNINST_PATCH_VERSION}")
 set (DYNINST_NAME "DyninstAPI-${VERSION_STRING}")
 
+if(BUILD_TARBALLS)
 find_package(Git)
 if(GIT_FOUND)
 if(EXISTS "${DYNINST_ROOT}/.git/")
 message(STATUS "Source tree is repository, building archive target")
 add_custom_target(package ALL)
 add_custom_command(TARGET package
-  COMMAND ${GIT_EXECUTABLE} archive --prefix="${DYNINST_NAME}/" -o "${CMAKE_BINARY_DIR}/${DYNINST_NAME}.tgz" HEAD
+  COMMAND ${GIT_EXECUTABLE} archive --prefix="${DYNINST_NAME}/" --format=tar.gz -o "${CMAKE_BINARY_DIR}/${DYNINST_NAME}.tgz" HEAD
   WORKING_DIRECTORY ${DYNINST_ROOT}
   COMMENT "Packaging Dyninst")
-install(FILES "${CMAKE_BINARY_DIR}/${DYNINST_NAME}.tgz"
-  DESTINATION ${CMAKE_INSTALL_PREFIX})
+endif()
 endif()
 endif()
 
diff --git a/cmake/DyninstConfig.cmake.in b/cmake/DyninstConfig.cmake.in
index 2b93557..7578e46 100644
--- a/cmake/DyninstConfig.cmake.in
+++ b/cmake/DyninstConfig.cmake.in
@@ -16,7 +16,7 @@ foreach(TARG @ALL_DYNINST_TARGETS@)
   include ("${DYNINST_CMAKE_DIR}/${TARG}Targets.cmake" OPTIONAL)
 endforeach()
 
-set (DYNINST_LIBRARIES "dyninst")
+set (DYNINST_LIBRARIES "dyninstAPI")
 
 # Other variables Dyninst mutators may depend on
 set (DYNINST_PLATFORM "@PLATFORM@")
@@ -35,3 +35,10 @@ if(DYNINST_FIND_COMPONENTS)
     endif()
   endforeach()
 endif()
+
+if(TARGET dyninstAPI)
+  set(Dyninst_FOUND 1)
+else()
+  set(Dyninst_FOUND 0)
+endif()
+
diff --git a/cmake/options.cmake b/cmake/options.cmake
index 54463ed..efa1f55 100644
--- a/cmake/options.cmake
+++ b/cmake/options.cmake
@@ -1,10 +1,11 @@
 # Use SymtabAPI or SymLite?
-option (LIGHTWEIGHT_SYMTAB "Use lightweight symtab interface for ParseAPI, ProcControl, and Stackwalker" OFF)
+option (LIGHTWEIGHT_SYMTAB "Use lightweight symtab interface for ParseAPI, ProcControl, and Stackwalker; disables DyninstAPI build" OFF)
 
 # Use ParseAPI analysis in Stackwalker?
 option (SW_ANALYSIS_STEPPER "Use ParseAPI-based analysis stepper in Stackwalker" ON)
 
-#option (BUILD_RTLIB_32 "Build 32-bit runtime library on mixed 32/64 systems" ON)
+option (BUILD_TARBALLS "Build Dyninst package tarballs. Requires git archive, tar, gzip." OFF)
+option (BUILD_RTLIB_32 "Build 32-bit runtime library on mixed 32/64 systems" OFF)
 
 # Some global on/off switches
 if (LIGHTWEIGHT_SYMTAB)
diff --git a/cmake/packages.cmake b/cmake/packages.cmake
index 3a19483..9fb0399 100644
--- a/cmake/packages.cmake
+++ b/cmake/packages.cmake
@@ -102,7 +102,7 @@ endif()
 # an older CMake and it complains that it can't find Boost
 set(Boost_ADDITIONAL_VERSIONS "1.47" "1.47.0" "1.48" "1.48.0" "1.49" "1.49.0"
   "1.50" "1.50.0" "1.51" "1.51.0" "1.52" "1.52.0"
-  "1.53" "1.53.0" "1.54" "1.54.0" "1.55" "1.55.0" "1.56" "1.56.0")
+  "1.53" "1.53.0" "1.54" "1.54.0" "1.55" "1.55.0" "1.56" "1.56.0" "1.57" "1.57.0" "1.58" "1.58.0" "1.59" "1.59.0")
 
 set (Boost_DEBUG ON)
 set (PATH_BOOST "/usr" CACHE STRING "Path to boost")
diff --git a/common/h/entryIDs.h b/common/h/entryIDs.h
index c8e0a0e..df49198 100644
--- a/common/h/entryIDs.h
+++ b/common/h/entryIDs.h
@@ -560,6 +560,17 @@ enum entryID {
   e_unpcklps,
   e_verr,
   e_verw,
+  e_vinsertf128,
+  e_vextractf128,
+  e_vbroadcastss,
+  e_vbroadcastsd,
+  e_vbroadcastf,
+  e_vpmovswb,
+  e_vpmovsdb,
+  e_vpmovsqb,
+  e_vpmovsdw,
+  e_vpmovsqw,
+  e_vpmovsqd,
   e_vmread,
   e_vmwrite,
   e_vsyscall,
diff --git a/common/src/arch-x86.C b/common/src/arch-x86.C
index 7160d7e..176039b 100644
--- a/common/src/arch-x86.C
+++ b/common/src/arch-x86.C
@@ -98,7 +98,7 @@ enum {
 	SSEB00=0, SSEB01, SSEB02, SSEB03, SSEB04, SSEB05, SSEB06, SSEB07,
 	SSEB08, SSEB09,	SSEB0A, SSEB0B,
 	SSEB10, SSEB14, SSEB15, SSEB17,
-	SSEB1C, SSEB1D, SSEB1E,
+	SSEB18, SSEB19, SSEB1A, SSEB1B, SSEB1C, SSEB1D, SSEB1E,
 	SSEB20, SSEB21, SSEB22, SSEB23, SSEB24, SSEB25, 
 	SSEB28, SSEB29, SSEB2A, SSEB2B,
 	SSEB30, SSEB31, SSEB32, SSEB33, SSEB34, SSEB35, SSEB37,
@@ -112,6 +112,7 @@ enum {
 	SSET08=0, SSET09,
 	SSET0A, SSET0B, SSET0C, SSET0D, SSET0E, SSET0F,
 	SSET14, SSET15, SSET16, SSET17,
+	SSET18, SSET19,
 	SSET20, SSET21, SSET22,
 	SSET40, SSET41, SSET42,
 	SSET60, SSET61, SSET62, SSET63
@@ -810,9 +811,20 @@ COMMON_EXPORT dyn_hash_map<entryID, std::string> entryNames_IAPI = map_list_of
   (e_xor, "xor")
   (e_xorpd, "xorpd")
   (e_xorps, "xorps")
-  (e_fp_generic, "[FIXME: GENERIC FPU INSN]")
-  (e_3dnow_generic, "[FIXME: GENERIC 3DNow INSN]")
-  (e_No_Entry, "No_Entry")
+ (e_vinsertf128, "vinsertf128")
+ (e_vextractf128, "vextractf128")
+ (e_vbroadcastss, "vbroadcastss")
+ (e_vbroadcastsd, "vbroadcastsd")
+ (e_vbroadcastf, "vbroadcastf")
+ (e_vpmovswb, "vpmovswb")
+ (e_vpmovsdb, "vpmovsdb")
+ (e_vpmovsqb, "vpmovsqb")
+ (e_vpmovsdw, "vpmovsdw")
+ (e_vpmovsqw, "vpmovsqw")
+ (e_vpmovsqd, "vpmovsqd")
+ (e_fp_generic, "[FIXME: GENERIC FPU INSN]")
+ (e_3dnow_generic, "[FIXME: GENERIC 3DNow INSN]")
+ (e_No_Entry, "No_Entry")
         ;
 
 dyn_hash_map<prefixEntryID, std::string> prefixEntryNames_IAPI = map_list_of
@@ -1123,7 +1135,7 @@ true, { Eb, Gb, Zz }, 0, s1RW2R },
   /* 60 */
   { e_pushad, t_done, 0, false, { GPRS, eSP, Zz }, 0, s1R2RW },
   { e_popad,  t_done, 0, false, { GPRS, eSP, Zz }, 0, s1W2RW },
-  { e_bound,    t_done, 0, true, { Gv, Ma, Zz }, 0, s1R2R },
+  { e_bound,    t_done, 0, true, { Gv, Ma, Zz }, 0, s1R2R }, // or VEX
   { e_arpl,     t_done, 0, true, { Ew, Gw, Zz }, 0, s1R2R },
   { e_No_Entry,          t_ill,  0, false, { Zz, Zz, Zz }, 0, 0 }, // PREFIX_SEG_OVR
   { e_No_Entry,          t_ill,  0, false, { Zz, Zz, Zz }, 0, 0 }, // PREFIX_SEG_OVR
@@ -1174,7 +1186,7 @@ true, { Eb, Gb, Zz }, 0, s1RW2R },
   { e_lea, t_done, 0, true, { Gv, Mlea, Zz }, IS_NOP, s1W2R }, // this is just M in the book
                                                         // AFAICT the 2nd operand is not accessed
   { e_mov, t_done, 0, true, { Sw, Ew, Zz }, 0, s1W2R },
-  { e_pop, t_done, 0, true, { Ev, eSP, Zz }, 0, s1W2RW },
+  { e_pop, t_done, 0, true, { Ev, eSP, Zz }, 0, s1W2RW }, // or VEX XOP
   /* 90 */
   { e_nop,  t_done, 0, false, { Zz, Zz, Zz }, IS_NOP, sNONE }, // actually xchg eax,eax
   { e_xchg, t_done, 0, false, { eCX, eAX, Zz }, 0, s1RW2RW },
@@ -1235,8 +1247,8 @@ true, { Eb, Gb, Zz }, 0, s1RW2R },
   { e_No_Entry, t_grp, Grp2, true, { Ev, Ib, Zz }, 0, s1RW2R },
   { e_ret_near, t_done, 0, false, { Iw, Zz, Zz }, (IS_RET | IS_RETC), s1R | (fNEARRET << FPOS) },
   { e_ret_near, t_done, 0, false, { Zz, Zz, Zz }, (IS_RET), fNEARRET << FPOS },
-  { e_les,      t_done, 0, true, { ES, Gv, Mp }, 0, s1W2W3R },
-  { e_lds,      t_done, 0, true, { DS, Gv, Mp }, 0, s1W2W3R },
+  { e_les,      t_done, 0, true, { ES, Gv, Mp }, 0, s1W2W3R }, // or VEX
+  { e_lds,      t_done, 0, true, { DS, Gv, Mp }, 0, s1W2W3R }, // Or VEX
   { e_No_Entry, t_grp, Grp11, true, { Eb, Ib, Zz }, 0, s1W2R },
   { e_No_Entry, t_grp, Grp11, true, { Ev, Iz, Zz }, 0, s1W2R },
   /* C8 */
@@ -1634,10 +1646,10 @@ static ia32_entry threeByteMap[256] = {
 		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 		{ e_No_Entry, t_sse_bis, SSEB17, true, { Zz, Zz, Zz }, 0, 0 },
 		/* 18 */
-		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+		{ e_No_Entry, t_sse_bis, SSEB18, true, { Zz, Zz, Zz }, 0, 0 },
+		{ e_No_Entry, t_sse_bis, SSEB19, true, { Zz, Zz, Zz }, 0, 0 },
+		{ e_No_Entry, t_sse_bis, SSEB1A, false, { Zz, Zz, Zz }, 0, 0 },
+		{ e_No_Entry, t_sse_bis, SSEB1B, false, { Zz, Zz, Zz }, 0, 0 },
 		{ e_No_Entry, t_sse_bis, SSEB1C, true, { Zz, Zz, Zz }, 0, 0 },
 		{ e_No_Entry, t_sse_bis, SSEB1D, true, { Zz, Zz, Zz }, 0, 0 },
 		{ e_No_Entry, t_sse_bis, SSEB1E, true, { Zz, Zz, Zz }, 0, 0 },
@@ -1925,8 +1937,8 @@ static ia32_entry threeByteMap2[256] = {
 		{ e_No_Entry, t_sse_ter, SSET16, true, { Zz, Zz, Zz }, 0, 0 },
 		{ e_No_Entry, t_sse_ter, SSET17, true, { Zz, Zz, Zz }, 0, 0 },
 		/* 18 */
-		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+		{ e_No_Entry, t_sse_ter, SSET18, true, { Zz, Zz, Zz }, 0, 0 },
+		{ e_No_Entry, t_sse_ter, SSET19, true, { Zz, Zz, Zz }, 0, 0 },
 		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 		{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
@@ -3477,6 +3489,34 @@ static ia32_entry sseMapBis[][5] = {
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
 		},
+		{ /* SSEB18 */
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vbroadcastss, t_done, 0, true, { Vdq, Mq, Zz }, 0, s1RW2R }, // actually Mo through this series
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
+		},
+		{ /* SSEB19 */
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vbroadcastsd, t_done, 0, true, { Vdq, Mq, Zz }, 0, s1RW2R },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
+		},
+		{ /* SSEB1A */
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vbroadcastf, t_done, 0, true, { Vdq, Mq, Zz }, 0, s1RW2R },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
+		},
+		{ /* SSEB1B */
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vbroadcastf, t_done, 0, true, { Vdq, Wq, Ib }, 0, s1RW2R3R },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
+		},
 		{ /* SSEB1C */
 				{ e_pabsb, t_done, 0, true, { Pq, Qq, Zz }, 0, s1W2R },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
@@ -3500,42 +3540,42 @@ static ia32_entry sseMapBis[][5] = {
 		},
 		{ /* SSEB20 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vpmovswb,  t_done, 0, true, { Wdq, Vdq, Zz }, 0, s1W2R },
 				{ e_pmovsxbw, t_done, 0, true, { Vdq, Wdq, Zz }, 0, s1W2R },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
 		},
 		{ /* SSEB21 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vpmovsdb,  t_done, 0, true, { Wdq, Vdq, Zz }, 0, s1W2R },
 				{ e_pmovsxbd, t_done, 0, true, { Vdq, Wdq, Zz }, 0, s1W2R },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
 		},
 		{ /* SSEB22 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vpmovsqb,  t_done, 0, true, { Wdq, Vdq, Zz }, 0, s1W2R },
 				{ e_pmovsxbq, t_done, 0, true, { Vdq, Wdq, Zz }, 0, s1W2R },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
 		},
 		{ /* SSEB23 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vpmovsdw, t_done, 0, true, { Wdq, Vdq, Zz }, 0, s1W2R },
 				{ e_pmovsxwd, t_done, 0, true, { Vdq, Wdq, Zz }, 0, s1W2R },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
 		},
 		{ /* SSEB24 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vpmovsqw, t_done, 0, true, { Wdq, Vdq, Zz }, 0, s1W2R },
 				{ e_pmovsxwq, t_done, 0, true, { Vdq, Wdq, Zz }, 0, s1W2R },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
 		},
 		{ /* SSEB25 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vpmovsqd, t_done, 0, true, { Wdq, Vdq, Zz }, 0, s1W2R },
 				{ e_pmovsxdq, t_done, 0, true, { Vdq, Wdq, Zz }, 0, s1W2R },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 }
@@ -3766,20 +3806,30 @@ static ia32_entry sseMapTer[][3] = {
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_extractps, t_done, 0, true, { Ed, Vdq, Ib }, 0, s1W2R3R }, 
 		},
-		{ /* SSET20 */
+		{ /* SSET18 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vinsertf128, t_done, 0, true, { Vdq, Wq, Ib }, 0, s1W2R3R }, 
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+		},
+		{ /* SSET19 */
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+				{ e_vextractf128, t_done, 0, true, { Vdq, Wq, Ib }, 0, s1W2R3R }, 
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
+		},
+		{ /* SSET20 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_pinsrb, t_done, 0, true, { Vdq, RMb, Ib }, 0, s1W2R3R }, 
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 		},
 		{ /* SSET21 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_insertps, t_done, 0, true, { Vdq, UMd, Ib }, 0, s1W2R3R },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 		},
 		{ /* SSET22 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
-				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 				{ e_pinsrd_pinsrq, t_done, 0, true, { Vdq, Ey, Ib }, 0, s1W2R3R },
+				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
 		},
 		{ /* SSET40 */
 				{ e_No_Entry, t_ill, 0, false, { Zz, Zz, Zz }, 0, 0 },
@@ -3965,18 +4015,60 @@ ia32_instruction& ia32_decode(unsigned int capa, const unsigned char* addr, ia32
   instruct.size = pref.getCount();
   addr += instruct.size;
 
-  table = t_oneB;
-  if(idx == 0) {
-    // consume opcode
-    idx = addr[0];
-    instruct.size += 1;
-    addr += 1;
-  } else {
-    // opcode already consumed (prefix opcode)
+  if(pref.vex_prefix[0])
+  {
+      idx = addr[0];
+      instruct.size += 1;
+      addr += 1;
+      sseidx = oneByteMap[pref.getOpcodePrefix()].tabidx;
+      // VEX instruction or xop. If there's only one prefix, table is two-byte.
+      if(pref.vex_prefix[1] == 0)
+      {
+	  gotit = &twoByteMap[idx];
+      }
+      else
+      {
+	  // FIXME: not handling xop separately yet
+	  switch(pref.vex_prefix[0] & 0x03)
+	  {
+	  case 0:
+	      gotit = &oneByteMap[idx];
+	      // generally invalid
+	      break;
+	  case 1:
+	      gotit = &twoByteMap[idx];
+	      break;
+	  case 2:
+	      gotit = &threeByteMap[idx];
+	      break;
+	  case 3:
+	      gotit = &threeByteMap2[idx];
+	      if(sseidx) sseidx--; // mapping none/f3/66/f2 to none/66/f2
+	      break;
+	  default:
+	      assert(!"Can't happen: prefix & 0x03 outside 0-3 range");
+	      
+	  }
+      }
+      nxtab = gotit->otable;
+      //cerr << "\nVEX decode: idx = " << hex << (int) idx << ", sseidx = " << (int) sseidx 
+      //	   << ", num_prefixes = " << pref.getCount() << ", opcode prefix = " << (int)pref.getOpcodePrefix() << endl;
+  }
+  else
+  {
+      table = t_oneB;
+      if(idx == 0) {
+	  // consume opcode
+	  idx = addr[0];
+	  instruct.size += 1;
+	  addr += 1;
+      } else {
+	  // opcode already consumed (prefix opcode)
+      }
+      gotit = &oneByteMap[idx];
+      nxtab = gotit->otable;
   }
 
-  gotit = &oneByteMap[idx];
-  nxtab = gotit->otable;
 
   if(capa & IA32_DECODE_CONDITION) {
     assert(instruct.cond != NULL);
@@ -4012,6 +4104,7 @@ ia32_instruction& ia32_decode(unsigned int capa, const unsigned char* addr, ia32
       addr += 1;
       if(capa & IA32_DECODE_CONDITION)
     	condbits = idx & 0x0F;
+      //if(sseidx) sseidx--;
       break;
     case t_prefixedSSE:
       sseidx = gotit->tabidx;
@@ -5145,6 +5238,7 @@ bool ia32_decode_prefixes(const unsigned char* addr, ia32_prefixes& pref,
 {
   pref.count = 0;
   pref.prfx[0] = pref.prfx[1] = pref.prfx[2] = pref.prfx[3] = pref.prfx[4] = 0;
+  pref.vex_prefix[0] = pref.vex_prefix[1] = pref.vex_prefix[2] = 0;
   pref.opcode_prefix = 0;
   bool in_prefix = true;
 
@@ -5193,6 +5287,58 @@ bool ia32_decode_prefixes(const unsigned char* addr, ia32_prefixes& pref,
        ++pref.count;
        pref.prfx[3] = addr[0];
        break;
+    case PREFIX_MVEX:
+    case PREFIX_XOP:
+	pref.vex_prefix[2] = addr[3];
+	++pref.count;
+	// fall through
+    case PREFIX_VEX3:
+	pref.vex_prefix[1] = addr[2];
+	++pref.count;
+	switch(pref.vex_prefix[1] & 0x03)
+	{
+	case 0:
+	    pref.opcode_prefix = 0x00;
+	    break;
+	case 1:
+	    pref.opcode_prefix = 0x66;
+	    break;
+	case 2:
+	    pref.opcode_prefix = 0xF3;
+	    break;
+	case 3:
+	    pref.opcode_prefix = 0xF2;
+	    break;
+	default:
+	    assert(!"Can't happen: value & 0x03 not in 0...3");
+	}
+	// fall through
+    case PREFIX_VEX2:
+	pref.vex_prefix[0] = addr[1];
+	if(!pref.count)
+	{
+	    switch(pref.vex_prefix[0] & 0x03)
+	    {
+	    case 0:
+		pref.opcode_prefix = 0x00;
+		break;
+	    case 1:
+		pref.opcode_prefix = 0x66;
+		break;
+	    case 2:
+		pref.opcode_prefix = 0xF3;
+		break;
+	    case 3:
+		pref.opcode_prefix = 0xF2;
+		break;
+	    default:
+		assert(!"Can't happen: value & 0x03 not in 0...3");
+	    }
+	}
+	++pref.count;
+	++pref.count;
+	in_prefix = false; // VEX prefixes exclude all others
+	break;
     default:
        in_prefix=false;
     }
diff --git a/common/src/arch-x86.h b/common/src/arch-x86.h
index d710488..e063fe6 100644
--- a/common/src/arch-x86.h
+++ b/common/src/arch-x86.h
@@ -391,6 +391,11 @@ enum {
 #define PREFIX_SEGFS  (unsigned char)(0x64)
 #define PREFIX_SEGGS  (unsigned char)(0x65)
 
+#define PREFIX_MVEX (unsigned char)(0x62)
+#define PREFIX_VEX2 (unsigned char)(0xC5)
+#define PREFIX_VEX3 (unsigned char)(0xC4)
+#define PREFIX_XOP  (unsigned char)(0x8F)
+
 #define PREFIX_BRANCH0 (unsigned char)(0x2E)
 #define PREFIX_BRANCH1 (unsigned char)(0x3E)
 
@@ -492,6 +497,7 @@ class ia32_prefixes
   // so this array is extended to 5 elements
   unsigned char prfx[5];
   unsigned char opcode_prefix;
+  
  public:
   unsigned int getCount() const { return count; }
   unsigned char getPrefix(unsigned char group) const { assert(group <= 4); return prfx[group]; }
@@ -502,6 +508,7 @@ class ia32_prefixes
   unsigned char getOpcodePrefix() const { return opcode_prefix; }
   unsigned char getAddrSzPrefix() const { return prfx[3]; }
   unsigned char getOperSzPrefix() const { return prfx[2]; }
+  unsigned char vex_prefix[3];
 };
 
 // helper routine to tack-on rex bit when needed
diff --git a/dynC_API/doc/dynC_API.pdf b/dynC_API/doc/dynC_API.pdf
index d5cbf26..5afe136 100644
Binary files a/dynC_API/doc/dynC_API.pdf and b/dynC_API/doc/dynC_API.pdf differ
diff --git a/dyninstAPI/CMakeLists.txt b/dyninstAPI/CMakeLists.txt
index bc50c88..cb63419 100644
--- a/dyninstAPI/CMakeLists.txt
+++ b/dyninstAPI/CMakeLists.txt
@@ -199,7 +199,7 @@ if (UNIX)
   target_link_private_libraries(dyninstAPI ${Boost_LIBRARIES})
   target_link_private_libraries (dyninstAPI pthread)
 else()
-  target_link_private_libraries(dyninstAPI dbghelp WS2_32)
+  target_link_private_libraries(dyninstAPI dbghelp WS2_32 imagehlp)
 endif()
 
 install(SCRIPT "${RT_BINARY_DIR}/cmake_install.cmake")
diff --git a/dyninstAPI/h/BPatch_module.h b/dyninstAPI/h/BPatch_module.h
index d5d56d0..a7bc6b2 100644
--- a/dyninstAPI/h/BPatch_module.h
+++ b/dyninstAPI/h/BPatch_module.h
@@ -264,9 +264,6 @@ public:
     // returns the hybrid Analysis mode: normal, exploratory, defensive
     BPatch_hybridMode getHybridMode();
     
-    BPatchSnippetHandle*  insertInitCallback(BPatch_snippet& callback);
-
-    BPatchSnippetHandle*  insertFiniCallback(BPatch_snippet& callback);
 
 #ifdef IBM_BPATCH_COMPAT
     bool getLineNumbers(unsigned int &start, unsigned int &end);
diff --git a/dyninstAPI/h/BPatch_object.h b/dyninstAPI/h/BPatch_object.h
index 153446e..f674b1e 100644
--- a/dyninstAPI/h/BPatch_object.h
+++ b/dyninstAPI/h/BPatch_object.h
@@ -44,7 +44,8 @@ class BPatch_module;
 class BPatch_object;
 class BPatch_function;
 class BPatch_point;
-
+class BPatchSnippetHandle;
+class BPatch_snippet;
 namespace Dyninst { 
    namespace ParseAPI { 
       class CodeObject; 
@@ -146,6 +147,10 @@ class BPATCH_DLL_EXPORT BPatch_object {
     //  if there is not overlapping code. 
     bool findPoints(Dyninst::Address addr, std::vector<BPatch_point *> &points);
 
+    BPatchSnippetHandle*  insertInitCallback(BPatch_snippet& callback);
+
+    BPatchSnippetHandle*  insertFiniCallback(BPatch_snippet& callback);
+
 };
 
 #endif
diff --git a/dyninstAPI/src/BPatch_module.C b/dyninstAPI/src/BPatch_module.C
index 6e9112b..8f91787 100644
--- a/dyninstAPI/src/BPatch_module.C
+++ b/dyninstAPI/src/BPatch_module.C
@@ -914,41 +914,6 @@ Address BPatch_module::getLoadAddr()
    return mod->obj()->codeBase();
 }
 
-BPatchSnippetHandle* BPatch_module::insertInitCallback(BPatch_snippet& callback)
-{
-    BPatch_Vector<BPatch_function*> init_funcs;
-    findFunction("_init", init_funcs);    
-    if(!init_funcs.empty())
-    {
-        assert(init_funcs[0]);
-        BPatch_Vector<BPatch_point*>* init_entry = init_funcs[0]->findPoint(BPatch_entry);
-        if(init_entry && !init_entry->empty() && (*init_entry)[0])
-        {
-            startup_printf("\tinserting init snippet at 0x%lx\n", (*init_entry)[0]->getAddress());
-            return addSpace->insertSnippet(callback, *((*init_entry)[0]));
-        }
-    }
-    
-    return NULL;
-}
-
-BPatchSnippetHandle* BPatch_module::insertFiniCallback(BPatch_snippet& callback)
-{
-    BPatch_Vector<BPatch_function*> fini_funcs;
-    findFunction("_fini", fini_funcs);
-    if(!fini_funcs.empty())
-    {
-        assert(fini_funcs[0]);
-        BPatch_Vector<BPatch_point*>* fini_exit = fini_funcs[0]->findPoint(BPatch_exit);
-        if(fini_exit && !fini_exit->empty() && (*fini_exit)[0])
-        {
-            startup_printf("\tinserting fini snippet at 0x%lx\n", (*fini_exit)[0]->getAddress());
-            return addSpace->insertSnippet(callback, *((*fini_exit)[0]));
-        }
-    }
-    return NULL;
-}
-
 BPatch_function *BPatch_module::findFunctionByEntry(Dyninst::Address entry)
 {
     BPatch_function* func = addSpace->findFunctionByEntry(entry);
diff --git a/dyninstAPI/src/BPatch_object.C b/dyninstAPI/src/BPatch_object.C
index f8d3c4b..a08dfc5 100644
--- a/dyninstAPI/src/BPatch_object.C
+++ b/dyninstAPI/src/BPatch_object.C
@@ -37,6 +37,9 @@
 #include "dyntypes.h"
 #include "function.h"
 #include "block.h"
+#include "BPatch_function.h"
+#include "debug.h"
+#include "BPatch_point.h"
 
 const Dyninst::Address BPatch_object::E_OUT_OF_BOUNDS((Dyninst::Address) -1);
 
@@ -178,3 +181,38 @@ Dyninst::SymtabAPI::Symtab *Dyninst::SymtabAPI::convert(const BPatch_object *o)
    return o->obj->parse_img()->getObject();
 }
 
+BPatchSnippetHandle* BPatch_object::insertInitCallback(BPatch_snippet& callback)
+{
+    BPatch_Vector<BPatch_function*> init_funcs;
+    findFunction("_init", init_funcs);    
+    if(!init_funcs.empty())
+    {
+        assert(init_funcs[0]);
+        BPatch_Vector<BPatch_point*>* init_entry = init_funcs[0]->findPoint(BPatch_entry);
+        if(init_entry && !init_entry->empty() && (*init_entry)[0])
+        {
+            startup_printf("\tinserting init snippet at 0x%lx\n", (*init_entry)[0]->getAddress());
+            return as()->insertSnippet(callback, *((*init_entry)[0]));
+        }
+    }
+    
+    return NULL;
+}
+
+BPatchSnippetHandle* BPatch_object::insertFiniCallback(BPatch_snippet& callback)
+{
+    BPatch_Vector<BPatch_function*> fini_funcs;
+    findFunction("_fini", fini_funcs);
+    if(!fini_funcs.empty())
+    {
+        assert(fini_funcs[0]);
+        BPatch_Vector<BPatch_point*>* fini_exit = fini_funcs[0]->findPoint(BPatch_exit);
+        if(fini_exit && !fini_exit->empty() && (*fini_exit)[0])
+        {
+            startup_printf("\tinserting fini snippet at 0x%lx\n", (*fini_exit)[0]->getAddress());
+            return as()->insertSnippet(callback, *((*fini_exit)[0]));
+        }
+    }
+    return NULL;
+}
+
diff --git a/dyninstAPI/src/addressSpace.C b/dyninstAPI/src/addressSpace.C
index 308626c..f5f9432 100644
--- a/dyninstAPI/src/addressSpace.C
+++ b/dyninstAPI/src/addressSpace.C
@@ -1855,6 +1855,7 @@ bool AddressSpace::relocateInt(FuncSet::const_iterator begin, FuncSet::const_ite
              orig = curAddr;
              mapped_object *obj = findObject(curAddr);
              if (!obj) break;
+			 if(!(obj->parse_img()->isParsed())) break;
              block = obj->findOneBlockByAddr(curAddr);
              func = tframe.getFunc();
              offset = 0;
diff --git a/dyninstAPI/src/ast.C b/dyninstAPI/src/ast.C
index 566a193..a86bedc 100644
--- a/dyninstAPI/src/ast.C
+++ b/dyninstAPI/src/ast.C
@@ -3645,10 +3645,10 @@ unsigned AstNode::getTreeSize() {
 int_variable* AstOperandNode::lookUpVar(AddressSpace* as)
 {
   mapped_module *mod = as->findModule(oVar->pdmod()->fileName());
-  if(mod && (oVar->pdmod() == mod->pmod()))
+  if(mod && mod->obj())// && (oVar->pdmod() == mod->pmod()))
   {
-    int_variable* tmp = mod->obj()->findVariable(const_cast<image_variable*>(oVar));
-    return tmp;
+      int_variable* tmp = mod->obj()->findVariable(const_cast<image_variable*>(oVar));
+      return tmp;
   }
   return NULL;
 }
diff --git a/dyninstAPI/src/image.C b/dyninstAPI/src/image.C
index cb26541..cd93ca8 100644
--- a/dyninstAPI/src/image.C
+++ b/dyninstAPI/src/image.C
@@ -1360,7 +1360,7 @@ image::image(fileDescriptor &desc,
        interested **/
    struct filt_heap : SymtabCodeSource::hint_filt {
         bool operator()(SymtabAPI::Function * f) {
-            return f->getModule()->fullName() == "DYNINSTheap";
+            return f && f->getModule() && f->getModule()->fullName() == "DYNINSTheap";
         }
     } nuke_heap;
     filt = &nuke_heap;
@@ -1523,7 +1523,10 @@ parse_func *image::addFunction(Address functionEntryAddr, const char *fName)
      }
      region = *(regions.begin()); // XXX pick one, throwing up hands. 
 
-     pdmodule *mod = getOrCreateModule(linkedFile->getDefaultModule());
+     Module* st_mod;
+     linkedFile->findModuleByOffset(st_mod, functionEntryAddr);
+     
+     pdmodule *mod = getOrCreateModule(st_mod);
 
      // copy or create function name
      char funcName[32];
diff --git a/dyninstAPI/src/image.h b/dyninstAPI/src/image.h
index b557cea..e29e545 100644
--- a/dyninstAPI/src/image.h
+++ b/dyninstAPI/src/image.h
@@ -298,7 +298,7 @@ class image : public codeRange {
          bool parseGaps);
 
    void analyzeIfNeeded();
-
+   bool isParsed() { return parseState_ == analyzed; }
    parse_func* addFunction(Address functionEntryAddr, const char *name=NULL);
 
    // creates the module if it does not exist
diff --git a/dyninstAPI/src/pdwinnt.C b/dyninstAPI/src/pdwinnt.C
index 6889a63..962a106 100644
--- a/dyninstAPI/src/pdwinnt.C
+++ b/dyninstAPI/src/pdwinnt.C
@@ -1053,7 +1053,7 @@ inferiorHeapType PCProcess::getDynamicHeapType() const
 }
 
 
-void OS::get_sigaction_names(std::vector<std::string> &)
+void OS::get_sigaction_names(std::vector<std::string> &names)
 {
-	assert(0 && "Unimplemented");
+	//names.push_back("signal");
 }
diff --git a/dyninstAPI/src/unix.C b/dyninstAPI/src/unix.C
index 4cca544..33e339b 100644
--- a/dyninstAPI/src/unix.C
+++ b/dyninstAPI/src/unix.C
@@ -134,19 +134,21 @@ bool PCProcess::multithread_capable(bool ignoreIfMtNotSet) {
  **/
 static void findThreadFuncs(PCProcess *p, std::string func,
                             pdvector<func_instance *> &result) {
-    bool found = false;
-    mapped_module *lpthread = p->findModule("libpthread*", true);
+    const pdvector<func_instance*>* found = NULL;
+    mapped_object *lpthread = p->findObject("libpthread*", true);
     if (lpthread)
-        found = lpthread->findFuncVectorByPretty(func, result);
-    if (found)
+        found = lpthread->findFuncVectorByMangled(func);
+    if (found) {
+	result = *found;
         return;
-
-    mapped_module *lc = p->findModule("libc.so*", true);
+    }
+    mapped_object *lc = p->findObject("libc.so*", true);
     if (lc)
-        found = lc->findFuncVectorByPretty(func, result);
-    if (found)
+        found = lc->findFuncVectorByMangled(func);
+    if (found) {
+	result = *found;
         return;
-
+    }
     p->findFuncsByPretty(func, result);
 }
 
@@ -375,7 +377,7 @@ bool PCProcess::setEnvPreload(std::vector<std::string> &envp, std::string fileNa
         while( environ[i] != NULL ) {
             std::string envVar(environ[i]);
             if( envVar.find("LD_PRELOAD=") == 0 ) {
-                ld_preload_orig = environ[i];
+                ld_preload_orig = environ[i]+11;
             }else{
                 envp.push_back(envVar);
             }
diff --git a/instructionAPI/doc/instructionAPI.pdf b/instructionAPI/doc/instructionAPI.pdf
index 1a5d196..4ae733c 100644
Binary files a/instructionAPI/doc/instructionAPI.pdf and b/instructionAPI/doc/instructionAPI.pdf differ
diff --git a/parseAPI/doc/3-Example.tex b/parseAPI/doc/3-Example.tex
index 6983e01..09901ea 100644
--- a/parseAPI/doc/3-Example.tex
+++ b/parseAPI/doc/3-Example.tex
@@ -1,6 +1,22 @@
 \section{Examples}
 \label{sec:example}
 
+\subsection{Function Disassembly}
+
+The following example uses ParseAPI and InstructionAPI to disassemble
+the basic blocks in a function. As an example, it can be built with
+G++ as follows: \code{g++ -std=c++0x -o code\_sample code\_sample.cc -L<library
+  install path> -I<headers install path> -lparseAPI -linstructionAPI
+  -lsymtabAPI -lsymLite -ldynDwarf -ldynElf -lcommon -L<libelf path>
+  -lelf -L<libdwarf path> -ldwarf}. Note: this example must be
+compiled with C++11x support; for G++ this is enabled with
+\code{-std=c++0x}, and it is on by default for Visual Studio.
+
+\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
+\lstset{numbers=left, numberstyle=\tiny, stepnumber=5, numbersep=5pt}
+\lstset{showstringspaces=false}
+\lstinputlisting{code_sample.cc}
+
 \subsection{Control flow graph traversal}
 
 The following complete example uses the ParseAPI to parse a binary and
diff --git a/parseAPI/doc/API/CodeSource.tex b/parseAPI/doc/API/CodeSource.tex
index ddaf2f5..9971cd8 100644
--- a/parseAPI/doc/API/CodeSource.tex
+++ b/parseAPI/doc/API/CodeSource.tex
@@ -35,9 +35,9 @@ std::map< Address, std::string > & linkage()
 
 \begin{apient}
 struct Hint {
-    Address addr;
-    CodeRegion *region;
-    std::string name;
+    Address _addr;
+    CodeRegion *_region;
+    std::string _name;
     Hint(Addr, CodeRegion *, std::string);
 }
 std::vector< Hint > const& hints()
diff --git a/parseAPI/doc/parseAPI.pdf b/parseAPI/doc/parseAPI.pdf
index c3ee818..df5b065 100644
Binary files a/parseAPI/doc/parseAPI.pdf and b/parseAPI/doc/parseAPI.pdf differ
diff --git a/parseAPI/h/CodeSource.h b/parseAPI/h/CodeSource.h
index 29c3880..7f338be 100644
--- a/parseAPI/h/CodeSource.h
+++ b/parseAPI/h/CodeSource.h
@@ -74,8 +74,8 @@ class PARSER_EXPORT CodeRegion : public Dyninst::InstructionSource, public Dynin
     { return false; }
 
     /** interval implementation **/
-    Address low() const =0;
-    Address high() const =0;
+    virtual Address low() const =0;
+    virtual Address high() const =0;
 
     bool contains(Address) const;
 
@@ -83,6 +83,13 @@ class PARSER_EXPORT CodeRegion : public Dyninst::InstructionSource, public Dynin
 
 };
 
+template <typename OS>
+ OS& operator<< (OS& stream, const CodeRegion& cr)
+ {
+     stream << "[" << cr.low() << ", " << cr.high() << ")";
+     return stream;
+ }
+
 /* A starting point for parsing */
 struct Hint {
     Hint() : _addr(0), _reg(NULL), _name("") { }
diff --git a/parseAPI/src/CodeObject.C b/parseAPI/src/CodeObject.C
index 9a935cd..f9fec85 100644
--- a/parseAPI/src/CodeObject.C
+++ b/parseAPI/src/CodeObject.C
@@ -47,9 +47,9 @@ namespace {
     }
 }
 
-static const int ParseAPI_major_version = 8;
-static const int ParseAPI_minor_version = 2;
-static const int ParseAPI_maintenance_version = 0;
+static const int ParseAPI_major_version = 9;
+static const int ParseAPI_minor_version = 0;
+static const int ParseAPI_maintenance_version = 4;
 
 void CodeObject::version(int& major, int& minor, int& maintenance)
 {
diff --git a/parseAPI/src/CodeSource.C b/parseAPI/src/CodeSource.C
index f155791..3db6359 100644
--- a/parseAPI/src/CodeSource.C
+++ b/parseAPI/src/CodeSource.C
@@ -30,7 +30,7 @@
  */
 #include <vector>
 #include <map>
-
+#include <iostream>
 #include <boost/assign/list_of.hpp>
 
 #include "dyntypes.h"
@@ -53,8 +53,15 @@ CodeSource::addRegion(CodeRegion * cr)
     if(!_regions_overlap) {
         set<CodeRegion *> exist;
         _region_tree.find(cr,exist);
-        if(!exist.empty())
+        if(!exist.empty()) {
+	    // for(auto i = exist.begin();
+	    // 	i != exist.end();
+	    // 	++i)
+	    // {
+	    // 	std::cerr << "Region " << **i << " overlaps " << *cr << std::endl;
+	    // }
             _regions_overlap = true;
+	}
     }
 
     _region_tree.insert(cr);
diff --git a/parseAPI/src/ProbabilisticParser.h b/parseAPI/src/ProbabilisticParser.h
index b031fac..a5ea563 100644
--- a/parseAPI/src/ProbabilisticParser.h
+++ b/parseAPI/src/ProbabilisticParser.h
@@ -198,6 +198,11 @@ class ProbabilityCalculator {
 
 public:
     ProbabilityCalculator(CodeRegion *reg, CodeSource *source, Parser *parser, std::string model_spec);
+	virtual ~ProbabilityCalculator() {
+		FEPProb.clear();
+	    reachingProb.clear();
+		finalized.clear();
+	}
     double calcProbByMatchingIdioms(Address addr);
     void calcProbByEnforcingConstraints();
     double getFEPProb(Address addr);
diff --git a/parseAPI/src/SymtabCodeSource.C b/parseAPI/src/SymtabCodeSource.C
index 5c4750d..130c482 100644
--- a/parseAPI/src/SymtabCodeSource.C
+++ b/parseAPI/src/SymtabCodeSource.C
@@ -590,6 +590,7 @@ SymtabCodeSource::lookup_region(const Address addr) const
 inline void 
 SymtabCodeSource::overlapping_warn(const char * file, unsigned line) const
 {
+    
     if(regionsOverlap()) {
         fprintf(stderr,"Invocation of routine at %s:%d is ambiguous for "
                        "binaries with overlapping code regions\n",
diff --git a/patchAPI/doc/patchAPI.pdf b/patchAPI/doc/patchAPI.pdf
index 4b40f31..576f28d 100644
Binary files a/patchAPI/doc/patchAPI.pdf and b/patchAPI/doc/patchAPI.pdf differ
diff --git a/patchAPI/src/PatchBlock.C b/patchAPI/src/PatchBlock.C
index 5ae7fd4..e33cb42 100644
--- a/patchAPI/src/PatchBlock.C
+++ b/patchAPI/src/PatchBlock.C
@@ -249,7 +249,8 @@ PatchBlock::containsDynamicCall() {
              } else { // check for register indirect
                  set<InstructionAST::Ptr> regs;
                  Expression::Ptr tExpr = insn->getControlFlowTarget();
-                 tExpr->getUses(regs);
+                 if (tExpr)
+                     tExpr->getUses(regs);
                  for (set<InstructionAST::Ptr>::iterator rit = regs.begin(); 
                       rit != regs.end(); rit++)
                  {
diff --git a/stackwalk/doc/stackwalk.pdf b/stackwalk/doc/stackwalk.pdf
index 5648acf..7455f25 100644
Binary files a/stackwalk/doc/stackwalk.pdf and b/stackwalk/doc/stackwalk.pdf differ
diff --git a/symlite/CMakeLists.txt b/symlite/CMakeLists.txt
index 0efeed3..343ae92 100644
--- a/symlite/CMakeLists.txt
+++ b/symlite/CMakeLists.txt
@@ -14,18 +14,18 @@ set (SRC_LIST
   )
 add_definitions(-DSYMLITE_LIB)
 
-add_library (symLite ${SRC_LIST})
-add_library (symLite_static STATIC ${SRC_LIST})
-FILE (GLOB headers "h/*.h")
-set_target_properties (symLite symLite_static PROPERTIES PUBLIC_HEADER "${headers}")
+#add_library (symLite ${SRC_LIST})
+#add_library (symLite_static STATIC ${SRC_LIST})
+#FILE (GLOB headers "h/*.h")
+#set_target_properties (symLite symLite_static PROPERTIES PUBLIC_HEADER "${headers}")
 
-target_link_private_libraries (symLite common)
-target_link_private_libraries (symLite dynElf)
-
-INSTALL (TARGETS symLite symLite_static
-        EXPORT DyninstTargets
-        RUNTIME DESTINATION ${INSTALL_LIB_DIR}
-        LIBRARY DESTINATION ${INSTALL_LIB_DIR}
-        ARCHIVE DESTINATION ${INSTALL_LIB_DIR}
-        PUBLIC_HEADER DESTINATION ${INSTALL_INCLUDE_DIR})
+#target_link_private_libraries (symLite common)
+#target_link_private_libraries (symLite dynElf)
 
+#INSTALL (TARGETS symLite symLite_static
+#        EXPORT DyninstTargets
+#        RUNTIME DESTINATION ${INSTALL_LIB_DIR}
+#        LIBRARY DESTINATION ${INSTALL_LIB_DIR}
+#        ARCHIVE DESTINATION ${INSTALL_LIB_DIR}
+#        PUBLIC_HEADER DESTINATION ${INSTALL_INCLUDE_DIR})
+dyninst_library(symLite common dynElf)
diff --git a/symtabAPI/doc/API/LineInfo/Iterating.tex b/symtabAPI/doc/API/LineInfo/Iterating.tex
index 76591e8..e6f3580 100644
--- a/symtabAPI/doc/API/LineInfo/Iterating.tex
+++ b/symtabAPI/doc/API/LineInfo/Iterating.tex
@@ -10,8 +10,8 @@ using namespace SymtabAPI;
 //Module handle for the module
 Module *mod;
 
-//Find the module foo within the object.
-obj->findModule(mod, foo);
+//Find the module \lq foo\rq within the object.
+obj->findModuleByName(mod, "foo");
 
 // Get the Line Information for module foo.
 LineInformation *info = mod->getLineInformation();
diff --git a/symtabAPI/doc/API/LineInfo/LineInformation.tex b/symtabAPI/doc/API/LineInfo/LineInformation.tex
index c1f72a3..13154eb 100644
--- a/symtabAPI/doc/API/LineInfo/LineInformation.tex
+++ b/symtabAPI/doc/API/LineInfo/LineInformation.tex
@@ -50,7 +50,7 @@ LineInformation::const_iterator begin() const
 \end{apient}
 \apidesc{
 This method returns an iterator pointing to the beginning of the line information for the module.
-This is useful for iterating over the entire line information present in a module. An example described in Section \ref{subsubsec:typeInfo} gives more information on how to use \code{begin()} for iterating over the line information.
+This is useful for iterating over the entire line information present in a module. An example described in Section \ref{subsec:LineNoIterating} gives more information on how to use \code{begin()} for iterating over the line information.
 }
 
 \begin{apient}
@@ -58,5 +58,5 @@ LineInformation::const_iterator end() const
 \end{apient}
 \apidesc{
 This method returns an iterator pointing to the end of the line information for the module.
-This is useful for iterating over the entire line information present in a module. An example described in Section \ref{subsubsec:typeInfo} gives more information on how to use \code{end()} for iterating over the line information.
+This is useful for iterating over the entire line information present in a module. An example described in Section \ref{subsec:LineNoIterating} gives more information on how to use \code{end()} for iterating over the line information.
 }
diff --git a/symtabAPI/doc/symtabAPI.pdf b/symtabAPI/doc/symtabAPI.pdf
index 8fb68c2..72c22df 100644
Binary files a/symtabAPI/doc/symtabAPI.pdf and b/symtabAPI/doc/symtabAPI.pdf differ
diff --git a/symtabAPI/h/Symtab.h b/symtabAPI/h/Symtab.h
index 078a1d5..babbe5a 100644
--- a/symtabAPI/h/Symtab.h
+++ b/symtabAPI/h/Symtab.h
@@ -363,8 +363,8 @@ class SYMTAB_EXPORT Symtab : public LookupInterface,
 
    std::string getDefaultNamespacePrefix() const;
 
-   unsigned getNumberofRegions() const;
-   unsigned getNumberofSymbols() const;
+   unsigned getNumberOfRegions() const;
+   unsigned getNumberOfSymbols() const;
 
    std::vector<std::string> &getDependencies();
    bool removeLibraryDependency(std::string lib);
diff --git a/symtabAPI/src/Module.C b/symtabAPI/src/Module.C
index 67b841f..6a22b1d 100644
--- a/symtabAPI/src/Module.C
+++ b/symtabAPI/src/Module.C
@@ -139,6 +139,10 @@ bool Module::getSourceLines(std::vector<Statement *> &lines, Offset addressInRan
    unsigned int originalSize = lines.size();
 
    LineInformation *lineInformation = getLineInformation();
+   if(!lineInformation) {
+     exec_->parseLineInformation();
+     lineInformation = getLineInformation();
+   }
    if (lineInformation)
       lineInformation->getSourceLines( addressInRange, lines );
 
diff --git a/symtabAPI/src/Object-elf.C b/symtabAPI/src/Object-elf.C
index 312d6d9..6feb825 100644
--- a/symtabAPI/src/Object-elf.C
+++ b/symtabAPI/src/Object-elf.C
@@ -4707,7 +4707,7 @@ void Object::parseStabFileLineInfo(Symtab *st)
   //  haveParsedFileMap[ key ] = true;
 } /* end parseStabFileLineInfo() */
 
-bool Object::addrInCU(Symtab* /*obj*/, Dwarf_Debug dbg, Dwarf_Die cu, Address to_check)
+bool Object::addrInCU(Symtab* obj, Dwarf_Debug dbg, Dwarf_Die cu, Address to_check)
 {
   Dwarf_Addr tempLow = 0, tempHigh = -1;
   Address low = 0, high = -1;
@@ -4946,7 +4946,20 @@ void Object::parseLineInfoForAddr(Symtab* obj, Offset addr_to_find)
 {
   Dwarf_Debug *dbg_ptr = dwarf->line_dbg();
   if (!dbg_ptr)
-    return; 
+    return;
+  Module* mod_for_offset = NULL;
+  obj->findModuleByOffset(mod_for_offset, addr_to_find);
+  std::string mod_to_check;
+  if(mod_for_offset)
+      
+  {
+      if(mod_for_offset->hasLineInformation())      // already parsed
+      {
+	  return;
+      }
+      mod_to_check = mod_for_offset->fileName();
+  }
+
   Dwarf_Debug &dbg = *dbg_ptr;
 
   /* Only .debug_info for now, not .debug_types */
@@ -4984,6 +4997,16 @@ void Object::parseLineInfoForAddr(Symtab* obj, Offset addr_to_find)
       else
 	moduleName = cuName;
     }
+    if(cuName && modules_parsed_for_line_info.find(cuName) != modules_parsed_for_line_info.end())
+    {
+	dwarf_dealloc(dbg, cuDIE, DW_DLA_DIE);
+	continue;
+    }
+    if(mod_to_check != "" && strcmp(moduleName, mod_to_check.c_str()) != 0)
+    {
+	dwarf_dealloc(dbg, cuDIE, DW_DLA_DIE);
+	continue;
+    }
     // Parse line info for each CU once, completely, if a user has asked for something within
     // that CU
     if(!addrInCU(obj, dbg, cuDIE, addr_to_find))
@@ -5016,7 +5039,8 @@ void Object::parseLineInfoForAddr(Symtab* obj, Offset addr_to_find)
     parseLineInfoForCU(cuDIE, li_for_module);
     if (cuName) 
     {
-      dwarf_dealloc( dbg, cuName, DW_DLA_STRING );  
+	modules_parsed_for_line_info.insert(cuName);
+	dwarf_dealloc( dbg, cuName, DW_DLA_STRING );  
     }
     
     /* Free this CU's DIE. */
diff --git a/symtabAPI/src/Object-elf.h b/symtabAPI/src/Object-elf.h
index 855dd6e..132b989 100644
--- a/symtabAPI/src/Object-elf.h
+++ b/symtabAPI/src/Object-elf.h
@@ -574,11 +574,13 @@ class Object : public AObject {
   bool find_catch_blocks(Elf_X_Shdr *eh_frame, Elf_X_Shdr *except_scn,
                          Address textaddr, Address dataaddr,
                          std::vector<ExceptionBlock> &catch_addrs);
-
+  // Line info: CUs to skip
+  std::set<std::string> modules_parsed_for_line_info;
 #if defined(cap_dwarf)
   std::string find_symbol(std::string name); 
   bool fixSymbolsInModule(Dwarf_Debug dbg, std::string & moduleName, Dwarf_Die dieEntry);
   unsigned fixSymbolsInModuleByRange(IntervalTree<Dwarf_Addr, std::string> &module_ranges);
+
 #endif
 
  public:
diff --git a/symtabAPI/src/Region.C b/symtabAPI/src/Region.C
index bc5ad59..d23b98d 100644
--- a/symtabAPI/src/Region.C
+++ b/symtabAPI/src/Region.C
@@ -67,6 +67,8 @@ Region::Region(unsigned regnum, std::string name, Offset diskOff,
     isDirty_(false), buffer_(NULL), isLoadable_(isLoadable), isTLS_(isThreadLocal),
     memAlign_(memAlignment), symtab_(NULL)
 {
+    //cerr << "Region " << name << ": [" << diskOff << ", " << diskOff + diskSize << ") (disk), ";
+    //cerr << "[" << memOff << ", " << memOff+memSize << ") (memory)" << endl;
    if (memOff)
       isLoadable_ = true;
 }
diff --git a/symtabAPI/src/Symbol.C b/symtabAPI/src/Symbol.C
index 517d39e..13fb1eb 100644
--- a/symtabAPI/src/Symbol.C
+++ b/symtabAPI/src/Symbol.C
@@ -112,10 +112,11 @@ SYMTAB_EXPORT string Symbol::getTypedName() const
   std::string working_name = mangledName_;
   #if !defined(os_windows)        
   //Remove extra stabs information
-  const char *p = strchr(working_name.c_str(), ':');
-  if( p ) {
-    unsigned nchars = p - mangledName_.c_str();
-    working_name = std::string(mangledName_.c_str(), nchars);
+  size_t colon;
+  colon = working_name.find(":");
+  if(colon != string::npos) 
+  {
+    working_name = working_name.substr(0, colon);
   }
 #endif     
   // Assume not native (ie GNU) if we don't have an associated Symtab for some reason
@@ -150,6 +151,7 @@ bool Symbol::setLocalTOC(Offset toc)
 
 SYMTAB_EXPORT bool Symbol::setModule(Module *mod) 
 {
+    assert(mod);
     module_ = mod; 
     return true;
 }
diff --git a/symtabAPI/src/Symtab-lookup.C b/symtabAPI/src/Symtab-lookup.C
index baf2264..65b9571 100644
--- a/symtabAPI/src/Symtab-lookup.C
+++ b/symtabAPI/src/Symtab-lookup.C
@@ -875,7 +875,7 @@ Module *Symtab::getDefaultModule() {
     if (_mods.size() == 1)
         return _mods[0];
     else {
-        if (!findModuleByName(mod, "DEFAULT_MODULE"))
+        if (!findModuleByName(mod, name()))
             return NULL;
     }
     return mod;
diff --git a/symtabAPI/src/Symtab.C b/symtabAPI/src/Symtab.C
index 0f852fd..a5cf460 100644
--- a/symtabAPI/src/Symtab.C
+++ b/symtabAPI/src/Symtab.C
@@ -788,13 +788,14 @@ bool Symtab::fixSymModule(Symbol *&sym)
     // else. This is enforced here, although the Object-* files might
     // do it as well.
     Module *mod = NULL;
-    if (getObjectType() == obj_SharedLib) {
-       mod = getDefaultModule();
-    }
-    else {
+    //if (0 && (getObjectType() == obj_SharedLib)) {
+    //   mod = getDefaultModule();
+    //}
+    //else {
        Object *obj = getObject();
        if (!obj)
        {
+	   assert(0);
           return false;
        }
        std::string modName = obj->findModuleForSym(sym);
@@ -804,7 +805,7 @@ bool Symtab::fixSymModule(Symbol *&sym)
        else {
           mod = getOrCreateModule(modName, sym->getOffset());
        }
-    }
+       //}
 
 
     if (!mod)
@@ -1137,24 +1138,24 @@ void Symtab::setModuleLanguages(dyn_hash_map<std::string, supportedLanguages> *m
 
 void Symtab::createDefaultModule() {
     Module *mod = NULL;
-    if (getObjectType() == obj_SharedLib) {
+    //    if (1 || getObjectType() == obj_SharedLib) {
         mod = new Module(lang_Unknown, 
                          imageOffset_,
                          name(),
                          this);
-    }
-    else {
-        mod = new Module(lang_Unknown, 
-                         imageOffset_,
-#if defined(os_vxworks)
+	//    }
+	//    else {
+        //mod = new Module(lang_Unknown, 
+	//                imageOffset_,
+			 //#if defined(os_vxworks)
                          // VxWorks' kernel objects should
                          // have their own module.
-                         name(),
-#else
-                         "DEFAULT_MODULE",
-#endif
-                         this);
-    }
+			 //                         name(),
+			 //#else
+			 //                         "DEFAULT_MODULE",
+			 //#endif
+			 //                         this);
+			 //    }
     modsByFileName[mod->fileName()] = mod;
     modsByFullName[mod->fullName()] = mod;
     _mods.push_back(mod);
@@ -2926,12 +2927,12 @@ SYMTAB_EXPORT std::string Symtab::memberName() const
     return member_name_;
 }
 
-SYMTAB_EXPORT unsigned Symtab::getNumberofRegions() const 
+SYMTAB_EXPORT unsigned Symtab::getNumberOfRegions() const 
 {
    return no_of_sections; 
 }
 
-SYMTAB_EXPORT unsigned Symtab::getNumberofSymbols() const 
+SYMTAB_EXPORT unsigned Symtab::getNumberOfSymbols() const 
 {
    return no_of_symbols; 
 }
